use lexer::token::{Token, LexicalError};
use super::ast;
//use lalrpop_util::ErrorRecovery;

grammar;
//grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token, LexicalError>>);

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token {
        "ABORT" => Token::Abort,
        "AND" => Token::And,
        "AS" => Token::As,
        "ASC" => Token::Asc,
        "BEGIN" => Token::Begin,
        "CASCADE" => Token::Cascade,
        "COMMIT" => Token::Commit,
        "COUNT" => Token::Count,
        "CREATE" => Token::Create,
        "DELETE" => Token::Delete,
        "DESC" => Token::Desc,
        "DISTINCT" => Token::Distinct,
        "DROP" => Token::Drop_,
        "END" => Token::End,
        "EXISTS" => Token::Exists,
        "FROM" => Token::From_,
        "HAVING" => Token::Having,
        "INDEX" => Token::Index,
        "INSERT" => Token::Insert,
        "INTO" => Token::Into_,
      //  "LIMIT" => Token::Limit,
        "NOT" => Token::Not,
        "ON DELETE" => Token::OnDelete,
        "OR" => Token::Or,
        "ORDER BY" => Token::OrderBy,
        "PRIMARY KEY" => Token::PrimaryKey,
        "REFERENCES" => Token::References,
        "ROLLBACK" => Token::Rollback,
        "SELECT" => Token::Select,
        "SET" => Token::Set,
        "TABLE" => Token::Table,
        "UPDATE" => Token::Update,
        "VACUUM" => Token::Vacuum,
        "VALUES" => Token::Values,
        "WHERE" => Token::Where,

        "BOOLEAN" => Token::Boolean,
        "INT" => Token::TypeInt,
        "NULL" => Token::Null,
        "NUMERIC" => Token::Numeric,
        "SERIAL" => Token::Serial,
        "VARCHAR" => Token::Varchar,

        "stringLit" => Token::StringLit(<String>),
        "identifier" => Token::Identifier(<String>),
        "tableCol" => Token::TableCol(<String>),
        "tableAll" => Token::TableAll(<String>),
        "i32" => Token::Integer(<i32>),
        "FALSE" => Token::False,
        "TRUE" => Token::True,


        ">" => Token::Gt,
        ">=" => Token::GtE,
        "<" => Token::Lt,
        "<=" => Token::LtE,
        "!=" => Token::NE,
        "<>" => Token::NE,

        "*" => Token::Asterisk,
        ";" => Token::Semicolon,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "," => Token::Comma,
        "." => Token::Period,
        "'" => Token::SingleQuote,
        "\"" => Token::DoubleQuote,
        "=" => Token::Equals,
        "-" => Token::Minus,
        "+" => Token::Plus,
    }
}

pub Script: Vec<ast::Stmt> = {
    <stmts: Stmt*> => stmts
}

Stmt: ast::Stmt = {
    
    <start:@L> <c: CreateTable> ";" <last:@R> => {
        ast::Stmt {
            begin : start,
            end : last,
            kind : ast::StmtKind::CreateTable(Box::new(c))
        }
    },
    <start:@L> <s: SelectStmt> ";" <last:@R> => {
        ast::Stmt {
            begin : start,
            end : last,
            kind : ast::StmtKind::Select(Box::new(s))
        }
    },
    <start:@L> <i: InsertStmt> ";" <last:@R> => {
        ast::Stmt {
            begin : start,
            end : last,
            kind : ast::StmtKind::Insert(Box::new(i))
        }
    },
 //   ! => { errors.push(<>);
   //     ast::Stmt {
     //       begin : 0,
       //     end : 0,
         //   kind : ast::StmtKind::Error
        //}
   // }
}

CreateTable: ast::CreateTable = {
    "CREATE" "TABLE" <i: Ident> "(" ")" => {
        ast::CreateTable {
            table: i
        }
    }
}

SelectStmt: ast::SelectStmt = {
    "SELECT" <distinct:"DISTINCT"?> <r: ResultColList> "FROM" <t: TableList> <w: WhereClause?> => match distinct { 
        None => ast::SelectStmt { 
            distinct: false,
            results: r,
            from: t,
            filter: w
        },
        Some(_distinct) => ast::SelectStmt {
            distinct: true,
            results: r,
            from: t,
            filter: w
        }
    },
}

InsertStmt: ast::InsertStmt = {
    "INSERT" "INTO" <i: Ident> <c: InsertCols?> "VALUES" <v: Values> => {
        ast::InsertStmt {
            table: i,
            cols: c,
            kind: ast::InsertStmtKind::Single(v)
        }
    },
    "INSERT" "INTO" <i: Ident> <c: InsertCols?> <s: SelectStmt> => {
        ast::InsertStmt {
            table: i,
            cols: c,
            kind: ast::InsertStmtKind::Bulk(Box::new(s))
        }
    }
}


Values = { "(" <ValueList> ")" };

ValueList = Comma<LiteralValue>;

InsertCols = { "(" <IdenList> ")"};

IdenList = Comma<Ident>;

ResultColList = Comma<ResultCol>;

ResultCol: ast::ResultCol = {
    "*" => ast::ResultCol { kind : ast::ResultColKind::All(None) },
    <start:@L> <table_all:"tableAll"> <last:@R> => {
        let split_index = table_all.find('.').unwrap();
        let (table, _all) = table_all.split_once('.').unwrap();
        ast::ResultCol { kind : ast::ResultColKind::All(Some(
            ast::Ident {
                begin : start,
                end : split_index,
                name : table.to_string()
            }
        ))}
    },
    <start:@L> <table_col:"tableCol"> <last:@R> => {
        let split_index = table_col.find('.').unwrap();
        let (table, col) = table_col.split_once('.').unwrap(); 
        ast::ResultCol { 
            kind : ast::ResultColKind::TableColumn(
                ast::TableColumn {
                    table: Some(ast::Ident {
                        begin: start,
                        end: split_index,
                        name: table.to_string()
                    }),
                    column: ast::Ident {
                        begin: split_index+1,
                        end: last,
                        name: col.to_string()
                    }
                }
            )
        }
    },
    <i: Ident> => ast::ResultCol { 
        kind : ast::ResultColKind::TableColumn(
            ast::TableColumn {
                table: None, 
                column: i
            }
        )
    }
}

TableList = Comma<FromTable>;

FromTable: ast::FromTable = {
    <i: Ident> => ast::FromTable { kind : ast::FromTableKind::Single(i)},
    // TODO: JOIN
}

WhereClause: ast::WhereClause = {
    "WHERE" <e: Expr> => {
        ast::WhereClause {
            expr: e,
        }
    }
}

Expr: ast::Expr = {
    #[precedence(level="0")]
    <lit: LiteralValue> => ast::Expr { kind : ast::ExprKind::Literal(lit)},
    <start:@L> <table_col:"tableCol"> <last:@R> => {
        let split_index = table_col.find('.').unwrap();
        let (table, col) = table_col.split_once('.').unwrap();
        ast::Expr {
            kind : ast::ExprKind::Column(
                ast::TableColumn {
                    table: Some(ast::Ident {
                        begin: start,
                        end: split_index,
                        name: table.to_string()
                    }),
                    column: ast::Ident {
                        begin: split_index+1,
                        end: last,
                        name: col.to_string()
                    }
                }
            )
        }
    },
    <i: Ident> => ast::Expr { kind : ast::ExprKind::Column(ast::TableColumn {
        table: None,
        column: i
        })
    },
    "(" <Expr> ")",
    "(" <s:SelectStmt> ")" => ast::Expr { kind : ast::ExprKind::SelectStmt(Box::new(s))},
    #[precedence(level="1")] #[assoc(side="right")]
    <u:UnOp> <e:Expr> => ast::Expr {
        kind : ast::ExprKind::Unop(u, Box::new(e))
    },
    #[precedence(level="2")] #[assoc(side="left")]
    <e1:Expr> <b:BinOp> <e2:Expr> => ast::Expr {
        kind : ast::ExprKind::Binop(b, Box::new(e1), Box::new(e2))
    }
}

UnOp: ast::UnOp = {
    "NOT" => ast::UnOp { kind : ast::UnOpKind::Not},
    "EXISTS" => ast::UnOp { kind : ast::UnOpKind::Exists},
}

BinOp: ast::BinOp = {
    "AND" => ast::BinOp { kind : ast::BinOpKind::And},
    "OR" => ast::BinOp { kind : ast::BinOpKind::Or},
    "+" => ast::BinOp { kind : ast::BinOpKind::Add},
    "-" => ast::BinOp { kind : ast::BinOpKind::Sub},
    "=" => ast::BinOp { kind : ast::BinOpKind::Eq},
    "<" => ast::BinOp { kind : ast::BinOpKind::Lt},
    "<=" => ast::BinOp { kind : ast::BinOpKind::LtE},
    ">" => ast::BinOp { kind : ast::BinOpKind::Gt},
    ">=" => ast::BinOp { kind : ast::BinOpKind::GtE},
    "<>" => ast::BinOp { kind : ast::BinOpKind::Ne},
    "!=" => ast::BinOp { kind : ast::BinOpKind::Ne},
}



LiteralValue: ast::LiteralValue = {
    #[precedence(level="0")]
    "NULL" => ast::LiteralValue { kind : ast::LiteralValueKind::Null },
    "TRUE" => ast::LiteralValue { kind : ast::LiteralValueKind::True },
    "FALSE" => ast::LiteralValue { kind : ast::LiteralValueKind::False },
    #[precedence(level="1")]
    <num:"i32"> => {
        ast::LiteralValue {
            kind : ast::LiteralValueKind::Numeric(num)
        }
    },
    #[precedence(level="2")]
    <str_lit:"stringLit"> => {
        ast::LiteralValue {
            kind : ast::LiteralValueKind::StringLit(str_lit)
        }
    }
    
}

Ident: ast::Ident = {
    <start:@L> <i:"identifier"> <last:@R> => {
        ast::Ident {
            begin : start,
            end : last,
            name : i
        }
    }
}

// Comma separated list of type T
Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
}

