use super::token::{Token, LexicalError};
use super::ast;
use std::str::FromStr;

grammar;

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token {
        "ABORT" => Token::Abort,
        "AND" => Token::And,
        "AS" => Token::As,
        "ASC" => Token::Asc,
        "BEGIN" => Token::Begin,
        "CASCADE" => Token::Cascade,
        "COMMIT" => Token::Commit,
        "COUNT" => Token::Count,
        "CREATE" => Token::Create,
        "DELETE" => Token::Delete,
        "DESC" => Token::Desc,
        "DISTINCT" => Token::Distinct,
        "DROP" => Token::Drop_,
        "END" => Token::End,
        "FROM" => Token::From_,
        "HAVING" => Token::Having,
        "INDEX" => Token::Index,
        "INSERT" => Token::Insert,
        "INTO" => Token::Into_,
        "LIMIT" => Token::Limit,
        "NOT" => Token::Not,
        "ON DELETE" => Token::OnDelete,
        "OR" => Token::Or,
        "ORDER BY" => Token::OrderBy,
        "PRIMARY KEY" => Token::PrimaryKey,
        "REFERENCES" => Token::References,
        "ROLLBACK" => Token::Rollback,
        "SELECT" => Token::Select,
        "SET" => Token::Set,
        "TABLE" => Token::Table,
        "UPDATE" => Token::Update,
        "VACUUM" => Token::Vacuum,
        "VALUES" => Token::Values,
        "WHERE" => Token::Where,

        "BOOLEAN" => Token::Boolean,
        "INT" => Token::TypeInt,
        "NULL" => Token::Null,
        "NUMERIC" => Token::Numeric,
        "SERIAL" => Token::Serial,
        "VARCHAR" => Token::Varchar,

        "identifier" => Token::Identifier(<String>),
        "i32" => Token::Integer(<i32>),
        "FALSE" => Token::False,
        "TRUE" => Token::True,


        ">" => Token::Gt,
        ">=" => Token::GtE,
        "<" => Token::Lt,
        "<=" => Token::LtE,
        "!=" => Token::NE,
        "<>" => Token::NE,

        "*" => Token::All,
        ";" => Token::Semicolon,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "," => Token::Comma,
        "." => Token::Period,
        "'" => Token::SingleQuote,
        "\"" => Token::DoubleQuote,
        "=" => Token::Equals,
        "-" => Token::Negative,
    }
}

pub Script: Vec<ast::Stmt> = {
    <stmts: Stmt*> => stmts
}

Stmt: ast::Stmt = {
    #[precedence(level="0")]
    "INSERT" <i: Ident> ";" => {
        ast::Stmt {
          kind :  ast::StmtKind::Variable { name: i }
        }
    },
    #[precedence(level="1")]
    "INSERT" Ident "=" <lit: LiteralValue> ";" => {
        ast::Stmt {
          kind :  ast::StmtKind::Lit { value: lit }
        }
    },
}

LiteralValue: ast::LiteralValue = {
    #[precedence(level="0")]
    "NULL" => ast::LiteralValue { kind : ast::LiteralValueKind::Null },
    "TRUE" => ast::LiteralValue { kind : ast::LiteralValueKind::True },
    "FALSE" => ast::LiteralValue { kind : ast::LiteralValueKind::False },
    #[precedence(level="1")]
    <num:"i32"> => {
        ast::LiteralValue {
            kind : ast::LiteralValueKind::Numeric { value: num }
        }
    },
    #[precedence(level="2")]
    <str_lit:Ident> => {
        ast::LiteralValue {
            kind : ast::LiteralValueKind::StringLit { value: str_lit.name }
        }
    }
    
}

Ident: ast::Ident = {
    <i:"identifier"> => {
        ast::Ident {
            name : i
        }
    }
}

