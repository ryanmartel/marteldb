use crate::parser::token::{Token, LexicalError};
use crate::parser::ast;
use std::str::FromStr;

grammar;

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token {
        "ABORT" => Token::Abort,
        "AND" => Token::And,
        "AS" => Token::As,
        "ASC" => Token::Asc,
        "BEGIN" => Token::Begin,
        "CASCADE" => Token::Cascade,
        "COMMIT" => Token::Commit,
        "COUNT" => Token::Count,
        "CREATE" => Token::Create,
        "DELETE" => Token::Delete,
        "DESC" => Token::Desc,
        "DISTINCT" => Token::Distinct,
        "DROP" => Token::Drop_,
        "END" => Token::End,
        "FROM" => Token::From_,
        "HAVING" => Token::Having,
        "INDEX" => Token::Index,
        "INSERT" => Token::Insert,
        "INTO" => Token::Into_,
        "LIMIT" => Token::Limit,
        "NOT" => Token::Not,
        "ON DELETE" => Token::OnDelete,
        "OR" => Token::Or,
        "ORDER BY" => Token::OrderBy,
        "PRIMARY KEY" => Token::PrimaryKey,
        "REFERENCES" => Token::References,
        "ROLLBACK" => Token::Rollback,
        "SELECT" => Token::Select,
        "SET" => Token::Set,
        "TABLE" => Token::Table,
        "UPDATE" => Token::Update,
        "VACUUM" => Token::Vacuum,
        "VALUES" => Token::Values,
        "WHERE" => Token::Where,

        "BOOLEAN" => Token::Boolean,
        "INT" => Token::TypeInt,
        "NULL" => Token::Null,
        "NUMERIC" => Token::Numeric,
        "SERIAL" => Token::Serial,
        "VARCHAR" => Token::Varchar,

        "identifier" => Token::Identifier(<String>),
        "i32" => Token::Integer(i32),
        ";" => Token::Semicolon,
    }
}

pub Script: Vec<ast::Statement> = {
    <stmts: Statement*> => stmts
}
pub Statement: ast::Statement = {
    "INSERT" <name:"identifier"> ";" => {
        ast::Statement::Variable { name }
    },
}
