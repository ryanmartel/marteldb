use super::token::{Token, LexicalError};
use super::ast;
use std::str::FromStr;

grammar;

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token {
        "ABORT" => Token::Abort,
        "AND" => Token::And,
        "AS" => Token::As,
        "ASC" => Token::Asc,
        "BEGIN" => Token::Begin,
        "CASCADE" => Token::Cascade,
        "COMMIT" => Token::Commit,
        "COUNT" => Token::Count,
        "CREATE" => Token::Create,
        "DELETE" => Token::Delete,
        "DESC" => Token::Desc,
        "DISTINCT" => Token::Distinct,
        "DROP" => Token::Drop_,
        "END" => Token::End,
        "FROM" => Token::From_,
        "HAVING" => Token::Having,
        "INDEX" => Token::Index,
        "INSERT" => Token::Insert,
        "INTO" => Token::Into_,
//        "LIMIT" => Token::Limit,
        "NOT" => Token::Not,
        "ON DELETE" => Token::OnDelete,
        "OR" => Token::Or,
        "ORDER BY" => Token::OrderBy,
        "PRIMARY KEY" => Token::PrimaryKey,
        "REFERENCES" => Token::References,
        "ROLLBACK" => Token::Rollback,
        "SELECT" => Token::Select,
        "SET" => Token::Set,
        "TABLE" => Token::Table,
        "UPDATE" => Token::Update,
        "VACUUM" => Token::Vacuum,
        "VALUES" => Token::Values,
        "WHERE" => Token::Where,

        "BOOLEAN" => Token::Boolean,
        "INT" => Token::TypeInt,
        "NULL" => Token::Null,
        "NUMERIC" => Token::Numeric,
        "SERIAL" => Token::Serial,
        "VARCHAR" => Token::Varchar,

        "identifier" => Token::Identifier(<String>),
        "tableCol" => Token::TableCol(<String>),
        "tableAll" => Token::TableAll(<String>),
        "i32" => Token::Integer(<i32>),
        "FALSE" => Token::False,
        "TRUE" => Token::True,


        ">" => Token::Gt,
        ">=" => Token::GtE,
        "<" => Token::Lt,
        "<=" => Token::LtE,
        "!=" => Token::NE,
        "<>" => Token::NE,

        "*" => Token::Asterisk,
        ";" => Token::Semicolon,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "," => Token::Comma,
        "." => Token::Period,
        "'" => Token::SingleQuote,
        "\"" => Token::DoubleQuote,
        "=" => Token::Equals,
        "-" => Token::Minus,
        "+" => Token::Plus,
    }
}

pub Script: Vec<ast::Stmt> = {
    <stmts: Stmt*> => stmts
}

Stmt: ast::Stmt = {
    <start:@L> "SELECT" <s: SelectStmt> ";" <last:@R> => {
        ast::Stmt {
            begin : start,
            end : last,
            kind : ast::StmtKind::Select(Box::new(s))
        }
    },
}

SelectStmt: ast::SelectStmt = {
    <distinct:"DISTINCT"?> <r: ResultCols> => match distinct {
        None => ast::SelectStmt { 
            distinct: false,
            results: r
        },
        Some(distinct) => ast::SelectStmt {
            distinct: true,
            results: r
        }
    },
}

ResultCols = Comma<ResultCol>;

ResultCol: ast::ResultCol = {
    "*" => ast::ResultCol { kind : ast::ResultColKind::All(None) },
    <tableAll:"tableAll"> => {
        let (table, _all) = tableAll.split_once('.').unwrap();
        ast::ResultCol { kind : ast::ResultColKind::All(Some(table.to_string()))}
    },
    <tableCol:"tableCol"> => {
        let (table, col) = tableCol.split_once('.').unwrap(); 
        ast::ResultCol { kind : ast::ResultColKind::Col(Some(table.to_string()), col.to_string())
        }
    },
    <i:"identifier"> => ast::ResultCol { kind : ast::ResultColKind::Col(None, i)}
}


LiteralValue: ast::LiteralValue = {
    #[precedence(level="0")]
    "NULL" => ast::LiteralValue { kind : ast::LiteralValueKind::Null },
    "TRUE" => ast::LiteralValue { kind : ast::LiteralValueKind::True },
    "FALSE" => ast::LiteralValue { kind : ast::LiteralValueKind::False },
    #[precedence(level="1")]
    <num:"i32"> => {
        ast::LiteralValue {
            kind : ast::LiteralValueKind::Numeric { value: num }
        }
    },
    #[precedence(level="2")]
    <str_lit:Ident> => {
        ast::LiteralValue {
            kind : ast::LiteralValueKind::StringLit { value: str_lit.name }
        }
    }
    
}

Ident: ast::Ident = {
    <i:"identifier"> => {
        ast::Ident {
            name : i
        }
    }
}

// Comma separated list of type T
Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
}

